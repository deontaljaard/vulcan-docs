{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Vulcan","text":"<p>Vulcan is a security scanning management, orchestration and reporting platform.</p>"},{"location":"#goal","title":"Goal","text":"<p>Allow teams to be independent in managing the security of their assets while reducing the toil associated with doing so. Allow security teams to focus on security instead of operations.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Single platform to consolidate all security scanning methods and asset types.</li> <li>Adapt any security tool (commercial, open source, custom...) to run on a large scale.</li> <li>Scan assets like servers, networks, Docker images, Git repositories, AWS accounts and more.</li> <li>Completely automated periodic scanning and reporting workflow for continuous scanning.</li> <li>Tooling to easily integrate most of the available security checks in the CI/CD process.</li> <li>Team tenancy to allow users to directly manage their security without intermediaries.</li> <li>Useful metrics such as critical assets, median exposure or mean time to remediate.</li> <li>Endless integration possibilities using the many available interfaces: UI, API, CLI, queues...</li> <li>Existing library of over 40 adapted and fine tuned security tools and custom checks. </li> </ul>"},{"location":"#highlighted-integrations","title":"Highlighted Integrations","text":""},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#simplified-architecture","title":"Simplified Architecture","text":"<p>This diagram shows the essential communication flow of Vulcan.</p> <p></p> <p>The main elements shown in the diagram are the following:</p> <ul> <li>Vulcan API: Manage teams, assets, users, scan policies and programs.</li> <li>Scan Engine: Creates checks on a schedule following scan programs.</li> <li>Agents: Execute, monitors and manage checks. Process and store results.</li> <li>VulnDB Consumer: Processes and stores results from checks on a timeline.</li> <li>VulnDB API: Provides access to catalogued issues, findings and statistics.</li> </ul> <p>Notably absent from this diagram are the following elements:</p> <ul> <li>User interfaces such as the Vulcan UI, the Vulcan Core CLI, Vulcan Local...</li> <li>Communication performed by specific checks requiring third-party services.</li> <li>Network devices (balancers, proxies, gateways...) necessary for communication.</li> <li>Communication interfaces such as message queues, notification topics and stream.</li> <li>Simple microservices (result storage, check inventory, metrics...) used for specific tasks.</li> <li>Specific runtimes (e.g. AWS, Kubernetes, GCP...) that the components can run inside of.</li> </ul>"},{"location":"architecture/#detailed-architecture","title":"Detailed Architecture","text":"<p>This diagram shows a more detailed architecture of Vulcan working in Kubernetes and AWS.</p> <p>For a complete list of all the components involved in Vulcan, see the repositories page.</p> <p></p>"},{"location":"asset-auto-discovery/","title":"Asset Auto-Discovery","text":"<p>Through its various interfaces, Vulcan can be connected to any external process that is able to discover assets. The Vulcan API has a discovery endpoint designed specifically for this. Vulcan can store and provide context to users about how specific assets were discovered. This allows users to simply add their main assets (e.g. an AWS account) manually in Vulcan and allow the external discovery process to use them to detect other assets that belong to the same team (e.g. EC2 instances, RDS databases...). Other examples include automatically onboarding assets into Vulcan whenever they are deployed (by calling the Vulcan API in the deployment process) or using an external asset inventory to keep the assets in Vulcan up to date.</p>"},{"location":"asset-auto-discovery/#examples","title":"Examples","text":"Assets that have been auto-discovered in the Vulcan web interface. Auto-discovery metadata for an asset in the Vulcan web interface."},{"location":"changelog/","title":"Changelog","text":"<p>TBD</p>"},{"location":"continuous-scanning/","title":"Continuous Scanning","text":"<p>Teams can create their own Vulcan team and add their assets there simply by pasting a list of identifiers (e.g. web addresses, hostnames, Github URL, AWS account ARN...) through the Vulcan user interface. By default, Vulcan will automatically start scanning those assets on a weekly schedule with checks that have been assessed to be not intrussive. Teams can manage their members and recipients, which will automatically receive a weekly report of the changes in the security of their assets. Through that report or directly on the Vulcan user interface, the team will be able to see which issues have been found in their assets and which assets need attention. All findings are accompanied with clear descriptions and information to help with remmediation. Users can autonomously mark findings as false positive and provide a rationale for it.</p>"},{"location":"continuous-scanning/#examples","title":"Examples","text":"Vulcan web interface showing periodic scans for a team. Vulcan web interface showing currently open findings for a team. Vulcan web interface showing the details of a specific finding."},{"location":"data-models/","title":"Data Models","text":""},{"location":"data-models/#vulnerability-db","title":"Vulnerability DB","text":"<pre><code>erDiagram\n    issues {\n      text id \"PK\"\n      text summary\n      int cwe_id\n      text description\n      text_array recomendations\n      text_array reference_links\n    }\n    issue_labels {\n      text issue_id \"PK, FK\"\n      text label \"PK, FK\"\n    }\n    findings {\n      text id \"PK\"\n      text issue_id \"FK\"\n      text target_id \"FK\"\n      text affected_resource\n      text status\n      text details\n      jsonb resources\n      float score\n      text impact_details\n      text fingerprint\n      text affected_resource_string\n    }\n    finding_events {\n      text id \"PK\"\n      text finding_id \"FK\"\n      text source_id \"FK\"\n      time time\n      float score\n      text details\n      jsonb resources\n      text fingerprint\n      text affected_resource_string\n    }\n    finding_exposures {\n      text finding_id \"PK, FK\"\n      time found_at \"PK\"\n      time fixed_at\n      int ttr\n      time expired_at\n    }\n    sources {\n      text id \"PK\"\n      text name\n      text component\n      text instance\n      text options\n      time time\n      text target_id \"FK\"\n    }\n    source_issues {\n      text source_id \"PK, FK\"\n      text issue_id \"PK, FK\"\n    }\n    last_sources {\n      text finding_id \"PK, FK\"\n      text source_id \"FK\"\n    }\n    targets {\n      text id \"PK\"\n      text identifier\n    }\n    target_teams {\n      text target_id \"PK, FK\"\n      text team_id \"PK\"\n    }\n    targets ||--o{ target_teams : \"\"\n    targets ||--o{ findings : \"\"\n    targets ||--o{ sources : \"\"\n    sources ||--o{ source_issues : \"\"\n    sources ||--o{ last_sources : \"\"\n    issues ||--o{ source_issues : \"\"\n    issues ||--o{ findings : \"\"\n    issues ||--o{ issue_labels : \"\"\n    findings ||--o{ finding_events : \"\"\n    findings ||--o{ finding_exposures : \"\"\n    findings ||--|| last_sources : \"\"</code></pre>"},{"location":"data-models/#vulcan-api","title":"Vulcan API","text":"<pre><code>erDiagram\n    teams {\n        uuid id \"PK\"\n        text name\n        text description\n        time created_at\n        time updated_at\n        text tag\n    }\n    user_team {\n        uuid user_id \"PK, FK\"\n        uuid team_id \"PK, FK\"\n        text role\n        time created_at\n        time updated_at\n    }\n    users {\n        uuid id \"PK\"\n        text firstname\n        text lastname\n        text email\n        text api_token\n        bool active\n        bool admin\n        time created_at\n        time updated_at\n        time last_login\n        bool observer\n    }\n    finding_overwrites {\n      uuid id \"PK\"\n      uuid user_id \"FK\"\n      uuid finding_id\n      uuid team_id\n      text status\n      text status_previous\n      text notes\n      time created_at\n    }\n    recipients {\n        uuid team_id \"PK, FK\"\n        text email \"PK\"\n        time created_at\n        time updated_at\n    }\n    assets {\n        uuid id \"PK\"\n        uuid team_id \"FK\"\n        uuid asset_type_id \"FK\"\n        text identifier\n        text options\n        text environmental_cvss\n        bool scannable\n        time created_at\n        time updated_at\n        text rolfp\n        time created_at\n        text alias\n    }\n    asset_annotations {\n        uuid asset_id \"PK, FK\"\n        text key \"PK\"\n        text value\n        time created_at\n        time updated_at\n    }\n    asset_types {\n        uuid id \"PK\"\n        text name\n    }\n    asset_group {\n        uuid asset_id \"PK, FK\"\n        uuid group_id \"PK, FK\"\n        time created_at\n        time updated_at\n    }\n    groups {\n        uuid id \"PK\"\n        uuid team_id \"FK\"\n        text name\n        text options\n        time created_at\n        time updated_at\n        text description\n    }\n    policies {\n        uuid id \"PK\"\n        uuid team_id \"FK\"\n        text name\n        bool global\n        time created_at\n        time updated_at\n        text description\n    }\n    checktype_settings {\n        uuid id \"PK\"\n        uuid policy_id \"FK\"\n        text check_type_name\n        text options\n        time created_at\n        time updated_at\n    }\n    programs {\n        uuid id \"PK\"\n        text name\n        text cron\n        time created_at\n        time updated_at\n        bool autosend\n        uuid team_id \"FK\"\n        bool disabled\n    }\n    programs_groups_policies {\n        uuid program_id \"PK, FK\"\n        uuid policy_id \"PK, FK\"\n        uuid group_id \"PK, FK\"\n    }\n    global_programs_metadata {\n        uuid team_id \"PK, FK\"\n        text program \"PK\"\n        bool autosend\n        time created_at\n        time updated_at\n        text cron\n        bool disabled\n    }\n    jobs {\n      uuid id \"PK\"\n      uuid team_id \"FK\"\n      text operation\n      text status\n      jsonb result\n      time created_at\n      time updated_at\n    }\n    teams ||--o{ user_team : \"\"\n    teams ||--o{ policies : \"\"\n    teams ||--o{ programs : \"\"\n    teams ||--o{ groups : \"\"\n    teams ||--o{ recipients : \"\"\n    teams ||--o{ assets : \"\"\n    teams ||--o{ global_programs_metadata : \"\"\n    teams ||--o{ jobs : \"\"\n    users ||--o{ finding_overwrites : \"\"\n    users ||--o{ user_team : \"\"\n    assets ||--o{ asset_group : \"\"\n    assets ||--o{ asset_annotations : \"\"\n    assets }o--|| asset_types : \"\"\n    policies ||--o{ checktype_settings : \"\"\n    policies ||--o{ programs_groups_policies : \"\"\n    programs ||--o{ programs_groups_policies : \"\"\n    groups ||--o{ programs_groups_policies : \"\"\n    groups ||--o{ asset_group : \"\"</code></pre> <pre><code>erDiagram\n    audit {\n        int id\n        time date\n        text schema\n        text tablename\n        text operation\n        text who\n        jsonb new_val\n        jsonb old_val\n    }\n    outbox {\n        uuid id \"PK\"\n        text operation\n        int version\n        jsonb data\n        int retries\n        time created_at\n        time updated_at\n    }</code></pre>"},{"location":"developing-checks/","title":"Developing Checks","text":"<p>Developing checks using the Go programming language is made simple using the Vulcan Check SDK. There is a large library of checks that can be taken as a reference. This page will show a commented skeleton to develop a simple check from scratch.</p> <p>The main code of the check is found in the <code>main.go</code> file.</p> main.go<pre><code>package main\n\nimport (\n  \"context\"\n  \"errors\"\n\n  check \"github.com/adevinta/vulcan-check-sdk\"\n  \"github.com/adevinta/vulcan-check-sdk/helpers\"\n  checkstate \"github.com/adevinta/vulcan-check-sdk/state\"\n  report \"github.com/adevinta/vulcan-report\"\n)\n\nvar (\n  checkName  = \"vulcan-example\"\n  logger     = check.NewCheckLog(checkName)\n  heartbleedVuln = report.Vulnerability{\n    CWEID:   326, // The applicable CWE ID for the vulnerability class.\n    Summary: \"Example Vulnerability\", // A title summary for the vulnerability.\n    Description: \"A comprehensive description of the vulnerability.\",\n    Score: 8.9, // The severity of the vulnerability.\n    ImpactDetails: \"Details about the potential impact of the vulnerability.\",\n    References: []string{ // Links to references with more information.\n      \"https://cve.mitre.org/\", // It is common to link the advisory.\n    },\n    Recommendations:  []string{\"A specific recommendation.\"},\n    Labels:           []string{\"issue\", \"ssl\"}, // Labels for filtering.\n    AffectedResource: \"443/tcp\", // Specific target resource checked.\n    // Fingerprint to separate instances of the same vulnerability.\n    // Used to re-open false positives if the circumstances change.\n    // No arguments indicate that the circumstances cannot change.\n    Fingerprint:      helpers.ComputeFingerprint(),\n  }\n)\n\nfunc isVulnerable(host string) (bool, error) {\n  // Add the actual logic to check for the vulnerability here.\n  return true, nil\n}\n\nfunc main() {\n  run := func(ctx context.Context, target, assetType, \n    optJSON string, state checkstate.State) (err error) {\n\n    // Verify that the check has a target. \n    if target == \"\" {\n      return errors.New(\"check target missing\")\n    }\n\n    // Use the SDK to verify if the check can reach the target.\n    // Reachability is defined differently depending on the asset type.\n    isReachable, err := helpers.IsReachable(target, assetType, nil)\n    if err != nil {\n      logger.Warnf(\"cannot check asset reachability: %v\", err)\n    }\n    if !isReachable {\n      return checkstate.ErrAssetUnreachable\n    }\n\n    // Call the actual function that will assess the target.\n    vulnerable, err := isVulnerable(target)\n    if err != nil {\n      state.Notes = err.Error()\n    }\n\n    if vulnerable {\n      // Add the defined vulnerability to the state of the check.\n      state.AddVulnerabilities(vulnerability)\n    }\n\n    return nil\n  }\n\n  c := check.NewCheckFromHandler(checkName, run)\n  c.RunAndServe()\n}\n</code></pre> <p>The <code>manifest.toml</code> file contains the metadata of the check.</p> manifest.toml<pre><code># The visible description of the check.\nDescription = \"Checks if an asset is vulnerable to an example vulnerability.\"\n# The asset types that the check will be used for by default.\nAssetTypes = [\"Hostname\", \"IP\"]\n</code></pre> <p>The <code>local.toml</code> file can be used to specify an example target for the check. This information is used when running the check binary on testing mode as we will see below.</p> local.toml<pre><code>[Check]\nTarget = \"example.com\" # Relevant target for the check.\nAssetType = \"Hostname\" # Asset type of the target.\n</code></pre> <p>To use the <code>local.toml</code> file to test a check before deploying it, you can just compile the binary and run it with the <code>-t</code> parameter from the same directory as the <code>local.toml</code> file.</p> <pre><code>go build -o vulcan-example main.go\n./vulcan-example -t\n</code></pre> <p>The <code>Dockerfile</code> file specifies how to package the check into a container image. This is specially relevant when the check requires to run in an specific environment such as when the Go code must execute third-party commands or interact with other applications. Otherwise, it will just copy and set the Go binary as the entry point for the container.</p> Dockerfile<pre><code>FROM alpine\nADD vulcan-example /vulcan-example\nCMD [\"/vulcan-example\"]\n</code></pre> <p>The container can be built, tested and deployed using the Vulcan Check Build System. In a complete Vulcan deployment, this should happen automatically as part of the CI/CD process.</p>"},{"location":"repositories/","title":"Repositories","text":"<p>This page contains a list of all public repositories related to Vulcan.</p>"},{"location":"repositories/#vulcan-core","title":"Vulcan Core","text":"<p>Components necessary for running scans and processing results.</p> <ul> <li>Vulcan Agent: Runs and monitors check containers. Retrieves and pushes results.</li> <li>Vulcan Checks: Code, manifest and container images for every available Vulcan check.</li> <li>Vulcan Scan Engine: Creates checks in a queue from a scan. Monitors the status of the scan.</li> <li>Vulcan Persistence: Inventory of the deployed checks, default options and required variables.</li> <li>Vulcan Results: Service used to upload and store check results from the agents.</li> <li>Vulcan Stream: WebSockets stream to push commands from the scan engine to the agents.</li> <li>Vulcan Check SDK: Go package to create Vulcan checks. Provides very useful helpers.</li> <li>Vulcan Report: Go package to define the Vulcan report format data model with helpers.</li> <li>Vulcan Build System: Tool to build, test, compare and deploy check container images.</li> </ul>"},{"location":"repositories/#vulcan-core-tools","title":"Vulcan Core Tools","text":"<p>Components that are not part with Vulcan Core but work with Vulcan Core.</p> <ul> <li>Vulcan Local: Tool to run Vulcan checks locally and as part of CI/CD pipelines.</li> <li>Vulcan Core CLI: Tool that interacts with the Scan Engine to launch a Vulcan scan.</li> <li>Vulcan Core Compose: Tool to deploy a local version of Vulcan Core using Docker Compose.</li> <li>Vulcan Groupie: Go package used by the Security Overview to group similar vulnerabilities.</li> </ul>"},{"location":"repositories/#vulcan-checks","title":"Vulcan Checks","text":"<p>Components that are used by one or more Vulcan checks.</p> <ul> <li>Restuss: Go client for the Tenable API. Fork of the unmaintained Restuss.</li> <li>Gozuul: Go package to detect and exploit NFLX-2016-003.</li> </ul>"},{"location":"repositories/#vulcan-service","title":"Vulcan Service","text":"<p>Components that allow users to interact with Vulcan and the data it generates.</p> <ul> <li>Vulcan API: Manages users, teams, assets, policies and programs. Acts as an API gateway.</li> <li>Vulnerability DB: Stores detected findings, affected targets. Tracks status, calculates metrics.</li> <li>Vulnerability DB API: Exposes the data stored in the Vulnerability DB through a REST API.</li> <li>Vulcan Reports Generator: Generates and sends findings digests from Vulcan data.</li> <li>Vulcan Crontinuous: Triggers periodic scans according to the scan program schedule.</li> <li>Vulcan Types: Go package to determine the type of an asset through different means.</li> <li>Errors: Go package to wrap and enrich errors in the Vulcan API.</li> </ul>"},{"location":"repositories/#common","title":"Common","text":"<p>Components used across Vulcan.</p> <ul> <li>Vulcan Charts: Helm charts used to deploy Vulcan in Kubernetes.</li> <li>Vulcan Metrics Client: Go package to abstract sending metrics from Vulcan components.</li> <li>Vulcan Types: Go package to define Vulcan asset types with helpers to identify them.</li> </ul>"},{"location":"repositories/#deprecated-repositories","title":"Deprecated Repositories","text":"<ul> <li>Vulcan CI/CD</li> <li>Dockerutils</li> <li>Security Overview</li> </ul>"},{"location":"security-checks-in-ci-cd/","title":"Security Checks in CI/CD","text":"<p>By using Vulcan Local, engineers are able to check the security of their services before even commiting new changes. Vulcan Local be integrated into the CI/CD process by uploading a simple YAML file into the repository, which will allow Vulcan Local to not only detect issues in code, but also in the artifacts created during the build process (e.g. libraries, Docker images...) and even run as part of the end-to-end tests to dynamically find vulnerabilities in web applications. Vulcan Local can report its output in various formats and can return an error code if some security criteria is met; it also allows teams to exclude specific findings if needed.</p>"},{"location":"security-checks-in-ci-cd/#build-example","title":"Build Example","text":"<p>This YAML file can be added into any repository to instruct Vulcan Local on how to scan it.</p> vulcan.yaml<pre><code># Policy to use, can be an HTTP URL.\nconf:\n  repositories:\n    - file://./script/checktypes-stable.json\n\n# List of targets to scan with all relevant checks.\ntargets:\n  - target: .\n  - target: http://localhost:1234/\n\n# List of specific checks to run.\nchecks:\n  - type: vulcan-gitleaks\n    target: .\n\n  - type: vulcan-zap\n    target: http://localhost:1234\n</code></pre> <p>Note that the <code>repositories</code> attribute allows developers to refer to an external security policy that will be used to decide which checks to run and which configuration to use for any of the targets provided, besides the checks specified in the YAML file itself. This allows developers to fall back to a default policy defined by the organization.</p> <p>With this file, invoking Vulcan Local in any build worker is as simple as executing two commands:</p> <pre><code># Install Vulcan Local.\ncurl -sfL \\\n https://raw.githubusercontent.com/adevinta/vulcan-local/master/script/get | sh\n# Run it using the YAML configuration.\nvulcan-local -c vulcan.yaml\n</code></pre>"},{"location":"security-checks-in-ci-cd/#local-example","title":"Local Example","text":"<p>Security engineers and software engineers can also use Vulcan Local to check the security of any reachable asset. This can be used to perform a quick security check or as part of the development process. For example, as a pre-commit hook to avoid pushing secrets to Github.</p> <pre><code># Install Vulcan Local.\ncurl -sfL \\\n https://raw.githubusercontent.com/adevinta/vulcan-local/master/script/get | sh\n# Run all checks that match the \"exposed\" keyword (e.g. \"vulcan-exposed-ftp\")\n# following the default policy against the target \"http://www.example.com\".\nvulcan-local -t http://www.example.com -i exposed \\\n -checktypes file://./script/checktypes-stable.json\n</code></pre>"},{"location":"security-metrics/","title":"Security Metrics","text":"<p>Vulcan can be used to query dynamically calculated security metrics for any of its teams, an arbitrary aggregation of teams or globally for the whole organization. These metrics can be used to answer questions about the security status of the organization and to set specific and measurable goals that teams can track themselves. Metrics for a specific team are made directly available to the team through the Vulcan API so they can be tracked as they see fit. Global metrics are only available to Vulcan administrators.</p> <p>Currently, the Vulcan API exposes the following metrics:</p> <ul> <li>Mean time to remediate fixed findings by vulnerability severity. Filterable by date and score.</li> <li>Current exposure time of open findings by percentiles. Filterable by date and score.</li> <li>Number of vulnerabile assets by severity. Filterable by a list of asset identifiers.</li> <li>Number of open findings by severity. Filterable by date and score.</li> <li>Number of fixed findings by severity. Filterable by date and score.</li> </ul> <p>All metrics can be aggregated by an arbitrary selection of teams.</p> <p>Below are just some examples of how these metrics can be retrieved. For more comprehensive examples, refer to the <code>stats</code> and <code>global-stats</code> sections of the Vulcan API specification.</p>"},{"location":"security-metrics/#team-examples","title":"Team Examples","text":"<p>The Vulcan API can be used to retrieve metrics for a team using the stats endpoint for the team.</p>"},{"location":"security-metrics/#how-many-open-vulnerabilities-does-a-specific-team-have","title":"How many open vulnerabilities does a specific team have?","text":"<pre><code># Retrieve currently open findings.\ncurl -H \"Authorization: Bearer $VULCAN_API_TOKEN\" \\\n\"www.vulcan.example.com/api/v1/teams/$TEAM_ID/stats/open\"\n\n{\n  \"open_issues\": {\n    \"critical\": 2,\n    \"high\": 4,\n    \"medium\": 9,\n    \"low\": 11,\n    \"informational\": 21\n  }\n}\n</code></pre>"},{"location":"security-metrics/#how-long-have-critical-vulnerabilities-in-a-specific-team-been-open-for","title":"How long have critical vulnerabilities in a specific team been open for?","text":"<pre><code># Retrieve current exposure (in hours) of open findings.\ncurl -H \"Authorization: Bearer $VULCAN_API_TOKEN\" \\\n\"www.vulcan.example.com/api/v1/teams/$TEAM_ID/stats/exposure/current?minScore=9\"\n\n{\n  \"current_exposure\": {\n    \"mean\": 41.209448947762005,\n    \"percentile_10\": 36.78803730882772,\n    \"percentile_25\": 50.75172645112574,\n    \"percentile_50\": 54.29089680729741,\n    \"percentile_75\": 72.78236287555608,\n    \"percentile_90\": 98.52142968051862\n  }\n}\n</code></pre>"},{"location":"security-metrics/#how-long-does-it-take-a-specific-team-to-resolve-vulnerabilities-on-average","title":"How long does it take a specific team to resolve vulnerabilities on average?","text":"<pre><code># Retrieve Mean Time To Remediate (in hours) of fixed findings.\ncurl -H \"Authorization: Bearer $VULCAN_API_TOKEN\" \\\n\"www.vulcan.example.com/api/v1/teams/$TEAM_ID/stats/mttr\"\n\n{\n  \"mttr\": {\n    \"critical\": 32.91856414183523,\n    \"high\": 82.43581388518908,\n    \"medium\": 140.39820739887437,\n    \"low\": 265.17825863008089,\n    \"informational\": 360.2830379559806,\n    \"total\": 103.571544865095874\n  }\n}\n</code></pre>"},{"location":"security-metrics/#global-examples","title":"Global Examples","text":"<p>The Vulcan API can be used to retrieve the same metrics globally using the global stats endpoint.</p>"},{"location":"security-metrics/#how-long-does-it-take-our-organization-to-resolve-vulnerabilities-on-average","title":"How long does it take our organization to resolve vulnerabilities on average?","text":"<pre><code># Retrieve Mean Time To Remediate (in hours) of fixed findings.\ncurl -H \"Authorization: Bearer $VULCAN_API_TOKEN\" \\\n\"www.vulcan.example.com/api/v1/stats/mttr\"\n\n{\n  \"mttr\": {\n    \"critical\": 44.91856414183523,\n    \"high\": 86.43581388518908,\n    \"medium\": 139.39820739887437,\n    \"low\": 267.17825863008089,\n    \"informational\": 362.2830379559806,\n    \"total\": 106.571544865095874\n  }\n}\n</code></pre>"},{"location":"security-metrics/#how-many-vulnerabilities-has-our-organization-fixed-in-the-last-quarter","title":"How many vulnerabilities has our organization fixed in the last quarter?","text":"<pre><code># Retrieve fixed findings between a date range.\ncurl -H \"Authorization: Bearer $VULCAN_API_TOKEN\" \\\n\"www.vulcan.example.com/api/v1/stats/fixed?minDate=2021-09-01&amp;maxDate=2021-12-01\"\n\n{\n  \"fixed_issues\": {\n    \"critical\": 19,\n    \"high\": 43,\n    \"medium\": 91,\n    \"low\": 265,\n    \"informational\": 141\n  }\n}\n</code></pre>"},{"location":"supported-assets/","title":"Supported Assets","text":"<p>By default, Vulcan is able to manage and scan the following asset types.</p> Asset Type Example Identifier Example Checks IP 127.0.0.1 Exposed and vulnerable services. IPRange 10.0.0.0/16 Exposed and vulnerable services. Hostname www.example.com Exposed and vulnerable services. DomainName example.com Phishing prevention and takeover. WebAddress https://www.example.com Web application scanning and leaks. AWSAccount arn:aws:iam::111111111111:root Security misconfiguration. DockerImage registry.hub.docker.com/organisation/image:latest Vulnerable libraries and packages. GitRepository https://github.com/organisation/repository.git Vulnerable libraries and secrets. <p>Note that the difference between a <code>Hostname</code> and a <code>DomainName</code> is that the first is a DNS name that resolves to a specific IP address (via A or AAAA records) and the second is a registered DNS name (with a SOA record) that does not need to resolve to any specific address but may contain other DNS records such as TXT, MX or CNAME.</p>"},{"location":"supported-assets/#asset-creation","title":"Asset Creation","text":"<p>Since the Vulcan API (and the UI) allows assets to be provided without a type, it will attempt to guess its type based on the format, even going as far as to extract and create multiple assets from a single identifier. For example, Vulcan would create three assets from the <code>https://www.example.com</code> identifier: a <code>WebAddress</code> (<code>https://www.example.com</code>), a <code>Hostname</code> (<code>www.example.com</code>) and a <code>DomainName</code> (<code>example.com</code>). Vulcan also provide endpoints to supply an asset with its associated type so that just that specific assets is added to Vulcan.</p>"},{"location":"vulcan-api/","title":"Vulcan API","text":""},{"location":"vulnerability-management/","title":"Vulnerability Management","text":"<p>This section aims to explain how Vulcan manages vulnerabilities.</p> <p>Although Vulcan is not primarily a vulnerability manager, it provides some vulnerability management functionality primarily designed to automate the process of detecting the presence and the resolution of vulnerabilities. However, it supports some user intervention such as flagging false positives. For more complex vulnerability management requirements, we currently recommend relying on the Vulcan API to fetch vulnerability information and use an external platform (e.g. a ticketing system) to suit your needs.</p>"},{"location":"vulnerability-management/#entities","title":"Entities","text":"<p>This section descrives the most relevant Vulcan entities related to vulnerability management.</p>"},{"location":"vulnerability-management/#affected-resource","title":"Affected Resource","text":"<p>Although in Vulcan users only manage assets (i.e. targets), vulnerabilities are found and stored in relation to specific resources in a target. Here are some examples:</p> <ul> <li>Hostname: the specific port and protocol where the vulnerability was detected.</li> <li>AWSAccount: the specific S3 bucket that allows public access.</li> <li>DockerImage: the specific package and version that is vulnerable.</li> <li>GitRepository: the specific file where a secret was found.</li> </ul> <p>Different checks and asset types will use different resources as \"affected resources\", which will always be stored in relation to the target where they were found.</p> <p>Besides providing more information to the users about where the vulnerability was found, associating vulnerabilities to the specific affected resources allows Vulcan to accurately represent multiple instances of the same vulnerability in the same target in order to keep track of more specific metrics and allow users to flag only some of them as false positive.</p>"},{"location":"vulnerability-management/#issue","title":"Issue","text":"<p>The generic instance of a vulnerability. When Vulcan detects a vulnerability for the first time an issue will be created containing the generic description and information about the vulnerability. An example of an issue would be <code>Outdated Packages in Docker Image</code> with its generic summary, description and recommendations.</p>"},{"location":"vulnerability-management/#finding","title":"Finding","text":"<p>An instance of an issue as detected in a specific affected resource. This entity contains more detailed information about what exactly has been found in the affected resource and can include relevant evidence, steps to reproduce in the target... Most importantly, a finding contains the state of that vulnerability in the specific affected resource, including the status (<code>OPEN</code>, <code>FIXED</code>, <code>FALSE_POSITIVE</code> or <code>EXPIRED</code>) and the age of the vulnerability among other data.</p> <p>An example would be an instace of <code>Outdated Packages in Docker Image</code> for the target <code>registry.hub.docker.com/organisation/image:latest</code>, where the affected resource is the <code>openjdk8-jre:8.252.09-r0</code> package. The finding would include which specific vulnerabilities affect this package version, which severity each one has, which CWE categories they correspond to and the minimum package version that resolves the vulnerabilities. This specific finding would also include, for example, details with a command that can be run locally to check if the fix has been implemented correctly before uploading a new version of that specific Docker image. </p>"},{"location":"vulnerability-management/#finding-states","title":"Finding States","text":""},{"location":"vulnerability-management/#open-fixed","title":"Open &amp; Fixed","text":"<p>A finding only exists if an instance of an issue has been found in a resource of a scanned target. Once this happens, the finding will be in <code>OPEN</code> status. From there, it will be automatically marked as <code>FIXED</code> when the target is scanned again with the same check and the finding is not found.</p>"},{"location":"vulnerability-management/#expired","title":"Expired","text":"<p>If a target is not scanned again with the same check after 90 days, the finding will be automatically marked as <code>EXPIRED</code>. This state exists due to the impossibility of veryfing that the finding has in fact been fixed. This happens, for example, when an asset becomes unreachable or when a check returns inconclusive results or is disabled altogether.</p>"},{"location":"vulnerability-management/#false-positive","title":"False Positive","text":"<p>False positives are flagged manually by the user using the Vulcan API or the UI. When a finding is flagged as false positive its state will automatically change to <code>FALSE_POSITIVE</code>. However, it may be automatically marked as <code>OPEN</code> if the fingerprint of the finding changes. The fingerprint is a unique identifier of the relevant characteristics of the finding that is calculated using different parameters for each check. For example, a check may include the list of relevant CVE as part of the fingerprint, so that when a new CVE is found for the same vulnerability in the same affected resource, the fingerprint will change. This ensures that flagging a finding as false positive does not prevent users from being reported when a vulnerability of the same class but with significantly different characteristics is found again in the same affected resource.</p> <pre><code>graph LR\n  A[Scan] --&gt; B{Finding found?};\n  B --&gt; |Yes| H{Flagged false positive?}\n  H --&gt; |Yes| I{Fingerprint changed?}\n  I --&gt; |No| J(FALSE_POSITIVE)\n  J --&gt; K{User re-opens?}\n  K --&gt; |No| G\n  K --&gt; |Yes| C\n  I --&gt; |Yes| C\n  H --&gt; |No| C(OPEN);\n  B --&gt; |No| D(FIXED);\n  B --&gt; |Inconclusive, unreachable...| E{Did 90 days pass?};\n  E --&gt; |Yes| F(EXPIRED)\n  E --&gt; |No| G[Wait for next scan..]\n  C --&gt; G\n  D --&gt; G\n  F --&gt; G\n  G --&gt; A</code></pre>"},{"location":"vulnerability-severity/","title":"Vulnerability Severity","text":"<p>For consistency, Vulcan attempts to use a common criteria for severity in all checks, sometimes going as far as to modify the severity provided by third-party tools to match the common criteria. This page contains basic descriptions of each severity in the context of Vulcan.</p> <p>Note that this criteria only considers the vulnerability itself regardless of its environment.</p>"},{"location":"vulnerability-severity/#critical","title":"Critical","text":"<p>Critical severity issues can directly result in the complete compromise of the asset and the information that it controls. They should be addressed as soon as possible. Examples include code injection vulnerabilities such as SQL injection or buffer overflow.</p>"},{"location":"vulnerability-severity/#high","title":"High","text":"<p>High severity issues can result in partial compromise of the asset and the information that it controls. In combination with other issues, authenticated access or user interaction, they can result in complete compromise of the asset. They should be prioritised and addressed soon. Examples include cross-site scripting and authenticated code injection.</p>"},{"location":"vulnerability-severity/#medium","title":"Medium","text":"<p>Medium severity issues usually correspond to security misconfigurations that unnecessarily expose the asset to attacks or may allow a successful attack to have greater impact. They should be taken into account and addressed whenever circumstances allow it. Examples include exposed network services, weak cryptography or lack of security controls.</p>"},{"location":"vulnerability-severity/#low","title":"Low","text":"<p>Low severity issues usually correspond to security practices that could be implemented to enhance the security of the asset. These practices reduce the risk of successful attacks and limit the impact of a potential compromise. They should be taken into account when creating new assets or making a change in the asset that allows for the practice to be implemented. Examples include support of medium-security cryptographic protocols or lack of modern security standards such as CSP, HSTS, DKIM, DMARC or SRI.</p>"},{"location":"vulnerability-severity/#informational","title":"Informational","text":"<p>Informational severity issues contain information found while scanning that may help provide context to users or the Security Team when investigating other issues. No action needs to be taken. Examples include information about the assets with regards to operating systems, running services, software versions, supported protocols or headers.</p>"}]}